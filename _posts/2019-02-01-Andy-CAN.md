---
title:  "AndyCAN - CAN Bus Hacking"
---

I've always been interested in cars, specifically the electronic systems and how they communicate together.
Many years ago I purchased a bluetooth OBDII adapter for diagnostic purposes.

![](https://cdn.shopify.com/s/files/1/1593/8481/products/1__63687.1469505628.1280.1280_1024x1024.jpg?v=1509855518)

The adapter could pair to an Android phone and read fault codes the car has thrown, typically associated with a check engine light. Often times this would be a bad oxygen sensor, spark plug, or electronic failure.

One of the applications I came across was a neat little cool called [Torque](https://play.google.com/store/apps/details?id=org.prowl.torque&hl=en_US). Torque allowed a user to pair to one of these ELM327 OBDII adapters to not only read diagnostic error codes but also realtime information such as engine RPM, temperature, speed, and so on.

![](https://cnet1.cbsistatic.com/img/t6wi-J7gEWlsmiCGRb3azKiflLY=/2012/07/02/810317e5-fdc4-11e2-8c7c-d4ae52e62bcc/screenshot-1341263014888.png)

This information is quite useful but still a bit basic, and the refresh rate is slow - only one to two updates per second. Unfortunately this is a limitation of the ELM327 chipset on the adapter and the OBDII protocol but with the proper tools we can work around this and accomplish much, much more.

# Enter the CAN bus

A CAN bus - Controller Area Network - is exactly what it sounds like. A message-based protocol designed for vehicles and their different devices to communicate with each other. Most vehicles built in the US since 1994 have included at least one CAN bus, and recent OBDII implementations actually live atop the CAN bus - terminating in the OBDII port typically near the driver's footwell. In modern cars it's common to have several dozens of devices networked together and even multiple CAN buses in one vehicle.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/CAN-Bus-frame_in_base_format_without_stuffbits.svg/2880px-CAN-Bus-frame_in_base_format_without_stuffbits.svg.png)

In 2014 I purchased a 2009 Honda Accord. Not being satisfied with the data available over my OBDII bluetooth adapter, I acquired a copy of the Honda service manual (nearly 3,000 pages!) and started doing some research.

![](/assets/images/accord.jpg)

As it turns out, my car had two CAN buses (3 technically if you count the K-Line but we won't get into this). One bus called F-CAN running at 500kbps and a second bus called B-CAN running at 125kbps. Typically these buses are a pair of wires each and the service manual confirms this (CAN HI, CAN LO). Fortunately from the diagram we can see that the F-CAN bus is exposed directly through the OBDII port. Great! Unfortunately, the B-CAN is not and if we want to gather any data from it we are going to have to trace wiring diagrams to find a good location to tie in.

![](https://i.imgur.com/Dn24FWS.png)

F-CAN has lots of useful information being sent over it's bus. We can listen on all sorts of engine metrics such as throttle body position, RPM, current transmission gear, break pedal position, accelerator pedal position, steering wheel position, and tons more.

B-CAN has some interesting data too. There's a wakeup signal (the car doesn't want to drain the battery when it's sleeping - more on this later), lights and climate information, locks, windows, and so on. My goal was to tap into both of these.

# Let's tear apart my dashboard!

So where do you start? My initial thought was that I could access the F-CAN bus easily through the OBDII port so my primary focus was on getting access to B-CAN. Reading the service manual is a safe bet, there's lots of wiring diagrams in there. A whole bunch of wiring diagrams actually. Too many wiring diagrams to sift through easily and with a 3000 page PDF there isn't much we can do in terms of searching. 

![](https://i.imgur.com/FMEbohR.png)

After a good bit of research though I was able to find a B-CAN bus in the passenger front footwell, near some of the HVAC controls. Space was extremely limited here and I couldn't establish a very good connection. Engineers typically don't leave a bunch of unconnected wiring harnesses lying around so the best I could do was try and make a half-decent connection with an existing harness.

![](/assets/images/b_can.jpg)

Around this time, I ordered a MCP2515 CAN bus module and modified it to work with a Raspberry PI. This allowed me to capture and start analyzing a single CAN bus's messages over time but this was not the end goal I was looking for.

![](https://www.makerfabs.com/image/cache/makerfabs/CAN%20Module%20MCP2515/CAN%20Module%20MCP2515_1-1000x750.JPG)

Unhappy with this solution, and the fact that I preferred to access both F-CAN and B-CAN in the same physical location, I started tracing wires back to a common point. 

At this point I feel that it's important to mention this is my only vehicle and my ride to/from work. One small mistake and I could seriously mess things up. I was lucky and that didn't happen but I wouldn't recommend trying this at home.

![](/assets/images/dashboard.jpg)

# The gauge cluster

Both F-CAN and B-CAN connect together at the gauge control module. You might know this better by it's more common name, the gauge cluster. The service manual describes both a F-CAN and a B-CAN transceiver in the gauge cluster. Perfect!

![](http://i.imgur.com/giqdSCU.png)

Cool, a 32 pin wiring harness! It should have the wires we need.

![](http://i.imgur.com/dqLiwcO.png)

Wanting to move away from a Raspberry Pi, I ordered a ViewTool Ginko dual USB-CAN adapter.

![](https://lh3.googleusercontent.com/proxy/ZE03sNhdRWFufAvGKc13A-YgMXTV1es9BT3yaxNRL9E7DnPgs_HqCBsuLI-9nZT2yV3L3IcUK859CXdb80M670Hx5FxUoKTHT6vlaQz9xYVrKwl6Uz8SRu_1jPgD1ATdHk9gWhYt2tbv)

This would allow me to tie into both the F-CAN and H-CAN wire pairs behind the gauge cluster and expose them over a fast (480Mbps) USB interface. Luckily there was plenty of extra space behind the gauge cluster that I was able to attach the Ginko's wiring and hide it completely while running a single USB cable along the dashboard.

It was around this time that I started writing an Android application to start interpreting CAN messages. I was able to find a Java driver for the Ginko adapter and without a whole lot of difficulty was able to start receiving raw messages.

# CAN message format

A CAN message container contains several pieces of data but there are only two we really care about:
 * **ID** - 11 or 29 bits, lower IDs have priority on the bus
 * **Payload** - Up to 64 bits of data
 
Strangely on my car, the B-CAN bus only used 29 bit IDs and the F-CAN bus 11 bit IDs. Perhaps this is to avoid collision but it wasn't immediately obvious why the developers chose to do this.

In addition, we could see upwards of 2,000 messages per second on the F-CAN bus and 250 per second on B-CAN meaning that whatever computation we do must be efficient so as not to drop any important messages. To accomplish this processing I chose to use the [observer pattern with the RxJava library](https://github.com/ReactiveX/RxJava). This allows me to build streaming pipelines for CAN messages being received with complete control over decoding, filtering, rerouting, and interpretation.

 